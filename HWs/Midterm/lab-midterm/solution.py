# -*- coding: utf-8 -*-
"""Copy of Examen intra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18I1Qwf_z3HhDghLPqxIt_xdQNAU6IcQV
"""

import numpy as np

"""# IFT6390 - Lab Midterm Instructions

You have exactly 1 hour and 15 minutes to take this exam.

You need to submit your solutions as a `.py` file named `solution.py` to the Gradescope entry `Lab Midterm`.

Each function or method you are asked to implement is worth 1 point. 20% of the marks are given to visible autograder test cases for which the input and desired output is visible, and the remaining 80% of the points are given to autograder test cases for which you would not see the input and output.

---

Vous avez exactement 1 heure et 15 minutes pour passer cet examen.

Vous devez soumettre vos solutions sous la forme d'un fichier `.py` nommé `solution.py` à l'entrée Gradescope `Lab Midterm`.

Chaque fonction ou méthode que l'on vous demande d'implémenter vaut 1 point. 20% des points sont attribués aux cas d'autogestion visibles pour lesquels l'entrée et la sortie désirée sont visibles, et les 80% des points restants sont attribués aux cas d'autogestion pour lesquels vous ne verriez pas l'entrée et la sortie.

# Python basics

## 1 - Palindrome

Given an integer `x`, return `True` if `x` is a palindrome integer.

An integer is a palindrome when it reads the same backward as forward.

---

## 1 - Palindrome

Étant donné un nombre entier `x`, retourner `True` si `x` est un nombre entier palindrome.

Un nombre entier est un palindrome lorsqu'il se lit de la même façon à l'envers qu'à l'endroit.

---

Example 1:

`Input: x = 121`

`Output: True`

Example 2:

`Input: x = 123`

`Output: False`

Example 3:

`Input: x = -121`

`Output: False`
"""

def is_palindrome(x):
    """
    :x: int
    :return: bool
    """
    sequence = str(x) 
    reverse = sequence[::-1]  
    if reverse == sequence: 
      return True
    else:
      return False

"""## 2 - Contains duplicates

Given an integer list `nums` and an integer `k`, return `True` if there are two distinct indices `i` and `j` in the list such that `nums[i] == nums[j]` and `abs(i - j) <= k`.

---

## 2 - Contient des entrées dupliquées

Étant donnée une liste de nombres entiers `nums` et un nombre entier `k`, retourne `True` s'il existe deux indices distincts `i` et `j` dans la liste tels que `nums[i] == nums[j]` et `abs(i - j) <= k`.

---

Example 1:

`Input: nums = [1,2,3,1], k = 3`

`Output: True`

Example 2:

`Input: nums =  [1,2,3,1,2,3], k = 2`

`Output: False`
"""

def contains_duplicates(nums, k):
    """
    :nums: list[int]
    :k: int
    :return: bool
    """
    find = False
    for i in range(len(nums)):
      for j in range(i+1, len(nums)):
        if nums[i]==nums[j] and abs(i-j)<=k:
          find = True
          return find
    return find

"""## 3 - Third maximum number

Given an integer list `nums`, return the third distinct maximum number in this list. If the third maximum does not exist, return the maximum number.

---

## 3 - Troisième nombre maximum

Étant donnée une liste de nombres entiers `nums`, retourne le troisième nombre maximum distinct dans cette liste. Si le troisième maximum n'existe pas, retourne le nombre maximum.

---

Example 1:

`Input: nums = [0,1,2,3,2]`

`Output: 1`

Example 2:

`Input: nums = [1,2]`

`Output: 2`
"""

def third_maximum(nums):
    """
    :nums: list[int]
    :return: int
    """     
    freq = {}
    nums = sorted(nums, reverse=True)
    ditinct = list(sorted(set(nums), reverse= True))
    for items in nums:
            freq[items] = nums.count(items)
    if len(nums)<=2:
      return nums[0]
    else:
      if freq[ditinct[2]]>1:
        return nums[0]
      else:
        return ditinct[2]

"""## 4 - Missing number

Given an integer list `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the list.

---

## 4 - Numéro manquant

Étant donnée une liste de nombres entiers `nums` contenant `n` nombres distincts dans l'intervalle `[0, n]`, retourner le seul nombre dans l'intervalle qui manque dans la liste.

---

Example 1:

`Input: nums = [3,0,1]`

`Output: 2`

Example 2:

`Input: nums = [0,1]`

`Output: 2`
"""

def missing_number(nums):
    """
    :nums: list[int]
    :return: int
    """ 
    return [i for i in range(len(nums)+1) if i not in nums][0]

"""## 5 - Valid Parentheses
Given a string s containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

---

## 5 - Parenthèses valides

Étant donnée une chaîne de caractères `s` contenant uniquement les caractères `(`, `)`, `{`, `}`, `[` et `]`, déterminez si la chaîne d'entrée est valide.

Une chaîne est valide si :

1. Les parenthèses ouvertes doivent être fermées par le même type de parenthèses.
2. Les parenthèses ouvertes doivent être fermées dans le bon ordre.
3. Chaque parenthèse fermée a une parenthèse ouverte du même type.

---

Example 1:

`Input: s = "()"`

`Output: true`

Example 2:

`Input: s = "()[]{}"`

`Output: true`

Example 3:

`Input: s = "(]"`

`Output: false`
"""

def is_valid_parentheses(s):
    """
    :s: str
    :return: bool
    """
    # https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/
    stack = []
 
    # Traversing the Expression
    for char in s:
        if char in ["(", "{", "["]:
 
            # Push the element in the stack
            stack.append(char)
        else:
 
            # IF current character is not opening
            # bracket, then it must be closing.
            # So stack cannot be empty at this point.
            if not stack:
                return False
            current_char = stack.pop()
            if current_char == '(':
                if char != ")":
                    return False
            if current_char == '{':
                if char != "}":
                    return False
            if current_char == '[':
                if char != "]":
                    return False
 
    # Check Empty Stack
    if stack:
        return False
    return True

"""## 6 - Plus One
You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return the resulting array of digits.

---

## 6 - Plus un

On vous donne un **grand entier** représenté par une liste d'entiers `digits`, où chaque `digits[i]` est le `ith` chiffre de l'entier. Le grand nombre entier ne contient pas de "0" en tête.

Incrémente le grand nombre entier de un et retourne la liste de chiffres résultant.

---

Example 1:

`Input: digits = [1,2,3]`

`Output: [1,2,4]`

Example 2:

`Input: digits = [4,3,2,1]`

`Output: [4,3,2,2]`

Example 3:

`Input: digits = [9]`

`Output: [1,0]`
"""

def plus_one(digits):
    """
    :digits: List[int]
    :return: List[int]
    """
    # https://www.geeksforgeeks.org/adding-one-to-number-represented-as-array-of-digits/
    digits.reverse()
    n = len(digits)
    # Taking a carry variable in case if there is any carry
    carry = 0
      
    for i in range(n):
          
        # initially  carry is 0 so this is base case
        if(i == 0):
            digits[i] += (1 + carry)
          
        # If carry is not equal to zero it should be added to
        # array element at that position.
        elif(carry != 0):
            digits[i] += carry
              
        # Now to get carry, i.e.
        # If digits[i]>9 we get the value at tens place in carry
        # or else if digits[i]<9 carry will be 0
        carry = digits[i]//10
          
        # Now if carry is not equal to 0
        # so at that index we should keep the value present
        # at the ones place so we di digits[i]%10
        if(carry != 0):
            digits[i] = digits[i] % 10
              
    # Afte doing all that if carry is still there which means
    # one more element is needed to be added to the array
    if(carry != 0):
        digits.append(carry)
          
    # Now we reverse the array so that we get the final array
    digits.reverse()
    return digits

"""## 7 - Sum of Unique Elements
You are given an integer array `nums`. The unique elements of an array are the elements that appear **exactly once** in the array.

Return the **sum** of all the unique elements of `nums`.

---

## 7 - Somme des éléments uniques

On vous donne une liste de nombres entiers `nums`. Les éléments uniques de la liste sont les éléments qui apparaissent **exactement une fois**.

Retournez la **somme** de tous les éléments uniques de `nums`.

---

Example 1:

`Input: nums = [1,2,3,2]`

`Output: 4`

Example 2:

`Input: nums = [1,1,1,1,1]`

`Output: 0`

Example 3:

`Input: nums = [1,2,3,4,5]`

`Output: 15`
"""

def sum_of_unique(nums):
    """
    :nums: List[int]
    :return: int
    """
    freq = {}
    summ = 0
    for items in nums:
        if nums.count(items)==1:
          summ+=items
    return summ

"""# Machine Learning

## 8 - Histogram Methods / Histogrammes

### 1-d Histogram for binary classification

Histogram methods can be used to create a simple binary classification learning algorithm to be able to predict an output (y) any point in the input space $x \in \mathbb{R}$.

The steps for building this algorithm includes:
* Step 1: Divide the input space into small bins of equal sizes
* Step 2: Train by counting the number of training points in each region for each of the classess

For a given test point, the region in which the test point lies is identified and the majority class of that region is returned as the predicted class for the given test point. 


**Boundary Cases to consider**
* When the test point given to `predict()` falls into a bin that is empty, the method returns the label of the majority class (the class with the most examples in the training set given to `fit()`, we assume that the number of points of the two classes in the training set is different).
* When the test point given to `predict()` falls into a bin such that there is a tie between the two classes, the `fit()` should return the majority class of the entire training set. 
* When the test point given to `predict()` falls outside the bin area, the `fit()` should return the majority class of the entire training set. 


Complete the methods for the `HistogramMethod1d` class provided below for a binary classification task.

**Variable description**

`self.bins` : array of `self.n_bins`+1 elements 

The `fit` method should construct the `self.bins` variable which will contain the boundaries of the bins. For example,
if `self.n_bins` = 4 , then `self.bins` should be an array with 5 elements where the first element is the minimum value of the inputs, the last element is the maximum value of the inputs, and the remaining elemets are uniformly distributed in the array.

(note: you can also construct another array to keep track of the majority class in each bins in the fit method)

### Histogramme 1d pour classification binaire

Les méthodes à histogramme peuvent être utilisées pour une tâche de classification binaire, permettant de prédire une sortie (y) pour tout point de l'espace d'entrée $x \in \mathbb{R}$.

Ce classifieur consiste à

* Diviser l'espace d'entrée en cases de tailles égales
* Apprendre en comptant le nombre de points de chaque classe dans chaque case
* Pour un point de test, l'algorithme identifie la case dans lequel le point de test est et retourne la classe majoritaire de cette case.


**Cas limites à considérer**

Si un point donné à la méthode `predict()` tombe 
* dans une case vide,
* dans une case où il y a égalité entre les points d'entraînement de chaque classe
* ou à l'extérieur des cases
le classifieur doit renvoyer le label de la classe majoritaire dans l'ensemble d'entraînement (on assume qu'il y a un nombre différent de points pour chaque classe dans l'ensemble d'entraînement).


Complétez le code de la classe  `HistogramMethod1d` ci-dessous pour une taĉhe de classification binaire en 1d. 

**Description de variable**

`self.bins` : tableau de `self.n_bins`+1 elements 

La mehode `fit` doit construire le tableau `self.bins` qui contiendra lees limites de chaque cases. Par exemple, si `self.n_bins` = 4 , alors `self.bins` doit être un tableau de 5 élément ou 
* le premier élément est la valeur minimum des points de l'ensemble d'entraînement
* le dernier élément est la valeur maximum des points de l'ensemble d'entraînement
* les autres éléments sont uniformément répartis entre ces deux valeurs.

(note: vous pouvez aussi construire un autre tableau pour enregistrer la classe majoritaire de chaque case dans la méthode `fit`)
"""

class HistogramMethod1d():
    def __init__(self, n_bins):
        """Initialize a 1 dimensional Histogram based binary classifier

        :param n_bins: int
        """
        self.n_bins = n_bins
        self.bins = None
        
    def fit(self, X, y):
        """Train the binary classifier

        :param X: float np.array of size N x 1 (each row is a data point)
        :param y: int np.array of size N (class of each data point -1 or +1)

        """
        pass
    
    def predict(self, X):
        """For each data point in the input X, return the predicted class

        :param X: float np.array of size N x 1 (each row is a data point)
        :return: int np.array of size N (predicted class of each data point -1 or +1)
        """
        pass

"""### 2d Histogram

Now, implement a `HistogramMethod2d` taking into account both the dimensions at once.

**Variable description**

`self.bins` : array of size $ 2 \times$ (`self.n_bins`$+1$) 

Similarly to the 1d case, the `fit` method should construct the `self.bins` array. For example, if `self.n_bins` = 2, then `array([1, 2, 3],[0,2,4])` would be the array constructed by the `fit` method if the minimum and maximum values in the training set are 1 and 3 along the first dimension, and 0 and 4 along the second dimension.

### Histogramme 2d pour classification binaire

Implémentez maintenant le code de la classe `HistogramMethod2d` ci-dessous pour un problème de classification binaire en 2 dimensions.

**Description de variable**

`self.bins` : tableau de taille $ 2 \times$ (`self.n_bins`$+1$) 

Comme dans le cas 1d, la méthode `fit` doit construire le table `self.bins`. Par exemple, si `self.n_bins` = 2, alors le tableau `array([1, 2, 3],[0,2,4])` serait construit par la méthode `fit` si les valeurs minimales et maximales dans le jeu de données d'entraînement sont 1 et 3 pour la première dimension, et 0 et 4 pour la second dimension.
"""

class HistogramMethod2d():
    def __init__(self, n_bins):
        """Initialize a 2 dimensional Histogram based binary classifier

        :param bins: int
        
        """
        self.n_bins = bins
        self.bins = None

    def fit(self, X, y):
        """Train the binary classifier

        :param X: float np.array of size N x 2 (each row is a data point)
        :param y: int np.array of size N (class of each data point -1 or +1)
        """
        pass

    def predict(self, X):
        """For each data point in the input X, return the predicted class

        :param X: float np.array of size N x 2 (each row is a data point)
        :return: int np.array of size N (predicted class of each data point -1 or +1)
        """
        pass